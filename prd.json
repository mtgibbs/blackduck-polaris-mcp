{
  "project": "blackduck-polaris-mcp",
  "branchName": "ralph/portfolio-api",
  "description": "Extend the Portfolio API layer to cover all remaining CRUD operations for Applications, Projects, Branches, Labels, Profiles, Artifacts, Entitlements, Organization Settings, Risk Scoring, and Dashboard. This includes adding TypeScript interfaces for every new request/response shape, API functions in src/api/portfolio.ts, service wrappers in src/services/portfolio.ts, and MCP tool files in src/mcp/tools/ following existing project conventions. The OpenAPI spec at specs/portfolio.yaml is the canonical source of truth for all schemas, paths, and media types.",
  "userStories": [
    {
      "id": "PRD-P1",
      "title": "Add types for all new Portfolio resources",
      "description": "Add all missing TypeScript interfaces to src/types/polaris.ts that are needed by the remaining Portfolio API stories. Each interface must match the canonical schema defined in specs/portfolio.yaml. Add the interfaces at the end of the '// --- Portfolio ---' section (after the existing Branch interface, before '// --- Findings ---'). Do NOT modify any existing types. The following interfaces must be added:\n\n1. `CreateApplicationRequest` - Body for POST /{portfolioId}/applications. Fields: name (string, required), description (string, optional).\n2. `UpdateApplicationRequest` - Body for PATCH /{portfolioId}/applications/{id}. Fields: name (string, optional), description (string, optional), inTrash (boolean, optional), autoDeleteSetting (boolean, optional), branchRetentionPeriodSetting (number, optional).\n3. `CreateProjectRequest` - Body for POST /{portfolioId}/applications/{appId}/projects. Fields: name (string, required), description (string, optional).\n4. `UpdateProjectRequest` - Body for PATCH /{portfolioId}/applications/{appId}/projects/{projectId}. Fields: name (string, optional), description (string, optional), inTrash (boolean, optional), autoDeleteSetting (boolean, optional), branchRetentionPeriodSetting (number, optional).\n5. `CreateBranchRequest` - Body for POST /{portfolioId}/applications/{appId}/projects/{projectId}/branches. Fields: name (string, required).\n6. `UpdateBranchRequest` - Body for PATCH /{portfolioId}/applications/{appId}/projects/{projectId}/branches/{id}. Fields: name (string, optional), isDefault (boolean, optional).\n7. `ProjectSubResource` - Response item from GET /{portfolioId}/project-sub-resources. Fields: id (string), name (string), projectSubResourceType ('BRANCH' | 'PROFILE'), default (boolean, optional), additionalProperties (Array<{key: string, value: string}>, optional), project ({id: string, name: string}, optional), application ({id: string, name: string}, optional), _type (string, optional).\n8. `ProjectSubResourceCountItem` - Response item from GET /{portfolioId}/project-sub-resources/_actions/count. Fields: group ({key: string, value: string}), count (number), _type (string, optional).\n9. `Profile` - Response from GET /{portfolioId}/applications/{appId}/projects/{projectId}/profiles/{profileId}. Fields: id (string), name (string), organizationId (string, optional), projectId (string, optional), performActiveAttack (boolean, optional), default (boolean, optional), importSettings (Record<string, unknown>, optional), manualSettings (Record<string, unknown>, optional), _links (LinkEntry[], optional).\n10. `ProfileArtifact` - Response from POST and GET artifact endpoints. Fields: id (string), fileName (string, optional), fileHash (string, optional), fileSize (string, optional), artifactType (string, optional), signedUrl (string, optional), createdAt (string, optional).\n11. `CreateProfileArtifactRequest` - Body for POST /{portfolioId}/applications/{appId}/artifacts. Fields: fileName (string), fileHash (string), fileSize (string), artifactType (string).\n12. `Label` - Response item from label endpoints. Fields: id (string), name (string), description (string, optional), createdAt (string, optional), updatedAt (string, optional), _links (LinkEntry[], optional), _type (string, optional).\n13. `CreateLabelRequest` - Body for POST /labels. Fields: name (string, required), description (string, optional).\n14. `MergeLabelRequest` - Body for POST /labels/merge. Fields: labelsToMerge (string[], required - array of label UUIDs), targetLabel ({name: string, description?: string}, required).\n15. `ApplicationEntitlementItem` - Single entitlement within ApplicationEntitlementsResponse. Fields: entitlementId (string), type (string, optional), executionMode (string, optional), quantityUsed (number, optional).\n16. `ApplicationEntitlementsResponse` - Response from GET /{portfolioId}/applications/{appId}/entitlements. Fields: applicationId (string), entitlements (ApplicationEntitlementItem[]), _links (LinkEntry[], optional).\n17. `EntitlementQuantityUpdateRequest` - Body for PATCH /{portfolioId}/applications/{appId}/entitlements/quantity. Fields: entitlementIds (string[]), quantity (number).\n18. `EntitlementQuantityUpdateResponse` - Response from the quantity PATCH. Fields: entitlementIds (string[]), quantity (number), _links (LinkEntry[], optional).\n19. `PortfolioEntitlement` - Response from GET /{portfolioId}/entitlements. Fields: entitlementId (string), applicationCount (number, optional).\n20. `OrganizationSettings` - Response from GET /settings and body for PATCH /settings. Fields: allowLabelCreationForApplicationRoleUser (boolean), autoDeleteSetting (boolean, optional), branchRetentionPeriodSetting (number, optional).\n21. `RiskCategory` - Nested in RiskFactor. Fields: id (string, optional), name (string), impact (number).\n22. `RiskFactor` - Nested in RiskScoringSettings. Fields: id (string, optional), name (string), weight (number), description (string, optional), defaultCategory (string | number, optional), categories (RiskCategory[]).\n23. `RiskScoringSettings` - Response/body for GET/PUT /risk-scoring. Fields: isEnabled (boolean), riskFactors (RiskFactor[]).\n24. `DashboardItem` - Response item from GET /portfolios/{portfolioId}/dashboard. Fields: id (string), tenantId (string, optional), portfolioId (string, optional), portfolioItemId (string), portfolioItemName (string, optional), portfolioItemDescription (string, optional), criticalIssueCount (number, optional), highIssueCount (number, optional), mediumIssueCount (number, optional), lowIssueCount (number, optional), informationalIssueCount (number, optional), totalIssueCount (number, optional), portfolioSubItemCount (number, optional), lastScanTime (string, optional), scanTypes (string, optional), totalActivePolicyViolation (number, optional), subscriptionTypes (string, optional), labelIds (string[], optional), riskScore (number, optional).\n\nAfter adding, run `deno task check` and `deno task lint` and `deno fmt --check` to verify. Reference: specs/portfolio.yaml components/schemas section.",
      "acceptanceCriteria": [
        "All 24 interfaces listed above exist in src/types/polaris.ts in the '// --- Portfolio ---' section",
        "Each interface field name and type matches the corresponding schema in specs/portfolio.yaml",
        "No existing interfaces in src/types/polaris.ts are modified or removed",
        "RiskCategory is defined before RiskFactor, and RiskFactor before RiskScoringSettings (dependency order)",
        "ApplicationEntitlementItem is defined before ApplicationEntitlementsResponse",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Foundation story. All other stories depend on these types. Do not create separate type files; all portfolio types live in src/types/polaris.ts.",
      "claimed_by": "agent-1",
      "claimed_at": "2026-02-19T20:52:46Z"
    },
    {
      "id": "PRD-P2",
      "title": "Application CRUD (get, create, update, delete)",
      "description": "Implement full CRUD for a single application resource. This story adds 4 API functions, 4 service wrappers, and 4 MCP tool files.\n\n**API layer (src/api/portfolio.ts):**\nThe file already has `getApplication(portfolioId, applicationId)`. Add the following three functions:\n\n1. `createApplication(params: { portfolioId: string; body: CreateApplicationRequest }): Promise<Application>` - POST to `/api/portfolios/${portfolioId}/applications`. Use `client.fetch<Application>(path, { method: 'POST', body: params.body, accept: ACCEPT_APPS, contentType: ACCEPT_APPS })`. The ACCEPT_APPS constant already exists as `application/vnd.polaris.portfolios.applications-1+json`.\n2. `updateApplication(params: { portfolioId: string; applicationId: string; body: UpdateApplicationRequest }): Promise<Application>` - PATCH to `/api/portfolios/${portfolioId}/applications/${applicationId}`. Use `client.fetch<Application>(path, { method: 'PATCH', body: params.body, accept: ACCEPT_APPS, contentType: ACCEPT_APPS })`.\n3. `deleteApplication(params: { portfolioId: string; applicationId: string }): Promise<void>` - DELETE to `/api/portfolios/${portfolioId}/applications/${applicationId}`. Use `client.fetch<void>(path, { method: 'DELETE', accept: ACCEPT_APPS })`. Returns 204.\n\nAlso refactor the existing `getApplication` to use an options object pattern: `getApplication(params: { portfolioId: string; applicationId: string }): Promise<Application>`.\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interfaces and wrapper functions:\n- `GetApplicationOptions { portfolioId: string; applicationId: string }` - already exists partially as positional args, refactor to options object\n- `CreateApplicationOptions { portfolioId: string; name: string; description?: string }`\n- `UpdateApplicationOptions { portfolioId: string; applicationId: string; name?: string; description?: string; inTrash?: boolean; autoDeleteSetting?: boolean; branchRetentionPeriodSetting?: number }`\n- `DeleteApplicationOptions { portfolioId: string; applicationId: string }`\n\nEach service function delegates to the corresponding API function.\n\n**Tool files (src/mcp/tools/):**\n\n1. `get-application.ts` - Tool name: `get_application`. Schema: portfolio_id (z.string()), application_id (z.string()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`. Handler calls `getApplication()` from services, returns `jsonResponse(app)`.\n2. `create-application.ts` - Tool name: `create_application`. Schema: portfolio_id (z.string()), name (z.string()), description (z.string().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`. Handler calls `createApplication()` from services.\n3. `update-application.ts` - Tool name: `update_application`. Schema: portfolio_id (z.string()), application_id (z.string()), name (z.string().optional()), description (z.string().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`. Handler calls `updateApplication()` from services.\n4. `delete-application.ts` - Tool name: `delete_application`. Schema: portfolio_id (z.string()), application_id (z.string()). Annotations: `{ readOnlyHint: false, destructiveHint: true, openWorldHint: true }`. Handler calls `deleteApplication()` from services, returns `jsonResponse({ success: true })`.\n\n**Register all 4 tools** in src/mcp/tools/index.ts by importing them and adding to the `tools` array.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml paths /{portfolioId}/applications and /{portfolioId}/applications/{id}.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports createApplication, updateApplication, deleteApplication functions",
        "All API functions use the ACCEPT_APPS constant (application/vnd.polaris.portfolios.applications-1+json) for both Accept and Content-Type headers",
        "createApplication uses client.fetch with method POST",
        "updateApplication uses client.fetch with method PATCH",
        "deleteApplication uses client.fetch with method DELETE and returns void",
        "src/services/portfolio.ts exports CreateApplicationOptions, UpdateApplicationOptions, DeleteApplicationOptions interfaces and corresponding functions",
        "Service functions use options objects (not positional args) following project convention",
        "src/mcp/tools/get-application.ts exists with tool name 'get_application' and readOnlyHint: true",
        "src/mcp/tools/create-application.ts exists with tool name 'create_application' and readOnlyHint: false",
        "src/mcp/tools/update-application.ts exists with tool name 'update_application' and readOnlyHint: false",
        "src/mcp/tools/delete-application.ts exists with tool name 'delete_application' and destructiveHint: true",
        "All 4 tools use plain Zod objects for schema (NOT z.object())",
        "All 4 tools are imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Depends on PRD-P1 for CreateApplicationRequest, UpdateApplicationRequest types. The existing getApplication function uses positional args; refactor it to options object for consistency.",
      "claimed_by": "agent-4",
      "claimed_at": "2026-02-19T20:52:46Z"
    },
    {
      "id": "PRD-P3",
      "title": "Project CRUD (get, create, update, delete)",
      "description": "Implement full CRUD for a single project resource. This story adds 3 new API functions (getProject already exists), 3 new service wrappers, and 4 MCP tool files.\n\n**API layer (src/api/portfolio.ts):**\nThe file already has `getProject(portfolioId, applicationId, projectId)`. Add:\n\n1. `createProject(params: { portfolioId: string; applicationId: string; body: CreateProjectRequest }): Promise<Project>` - POST to `/api/portfolios/${portfolioId}/applications/${applicationId}/projects`. Use `client.fetch<Project>(path, { method: 'POST', body: params.body, accept: ACCEPT_PROJECTS, contentType: ACCEPT_PROJECTS })`. ACCEPT_PROJECTS already exists as `application/vnd.polaris.portfolios.projects-1+json`.\n2. `updateProject(params: { portfolioId: string; applicationId: string; projectId: string; body: UpdateProjectRequest }): Promise<Project>` - PATCH to `/api/portfolios/${portfolioId}/applications/${applicationId}/projects/${projectId}`. Use `client.fetch<Project>(path, { method: 'PATCH', body: params.body, accept: ACCEPT_PROJECTS, contentType: ACCEPT_PROJECTS })`.\n3. `deleteProject(params: { portfolioId: string; applicationId: string; projectId: string }): Promise<void>` - DELETE to `/api/portfolios/${portfolioId}/applications/${applicationId}/projects/${projectId}`. Use `client.fetch<void>(path, { method: 'DELETE', accept: ACCEPT_PROJECTS })`. Returns 204.\n\nAlso refactor the existing `getProject` to use an options object pattern.\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interfaces and wrapper functions:\n- `GetProjectOptions { portfolioId: string; applicationId: string; projectId: string }` - refactor existing\n- `CreateProjectOptions { portfolioId: string; applicationId: string; name: string; description?: string }`\n- `UpdateProjectOptions { portfolioId: string; applicationId: string; projectId: string; name?: string; description?: string; inTrash?: boolean; autoDeleteSetting?: boolean; branchRetentionPeriodSetting?: number }`\n- `DeleteProjectOptions { portfolioId: string; applicationId: string; projectId: string }`\n\n**Tool files (src/mcp/tools/):**\n\n1. `get-project.ts` - Tool name: `get_project`. Schema: portfolio_id, application_id, project_id (all z.string()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n2. `create-project.ts` - Tool name: `create_project`. Schema: portfolio_id, application_id, name (z.string()), description (z.string().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n3. `update-project.ts` - Tool name: `update_project`. Schema: portfolio_id, application_id, project_id (z.string()), name (z.string().optional()), description (z.string().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n4. `delete-project.ts` - Tool name: `delete_project`. Schema: portfolio_id, application_id, project_id (z.string()). Annotations: `{ readOnlyHint: false, destructiveHint: true, openWorldHint: true }`.\n\n**Register all 4 tools** in src/mcp/tools/index.ts.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml paths /{portfolioId}/applications/{applicationId}/projects and /{portfolioId}/applications/{applicationId}/projects/{projectId}.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports createProject, updateProject, deleteProject functions",
        "All API functions use the ACCEPT_PROJECTS constant for Accept and Content-Type headers",
        "createProject uses client.fetch with method POST",
        "updateProject uses client.fetch with method PATCH",
        "deleteProject uses client.fetch with method DELETE and returns void",
        "src/services/portfolio.ts exports CreateProjectOptions, UpdateProjectOptions, DeleteProjectOptions interfaces and corresponding functions",
        "src/mcp/tools/get-project.ts exists with tool name 'get_project' and readOnlyHint: true",
        "src/mcp/tools/create-project.ts exists with tool name 'create_project' and readOnlyHint: false",
        "src/mcp/tools/update-project.ts exists with tool name 'update_project' and readOnlyHint: false",
        "src/mcp/tools/delete-project.ts exists with tool name 'delete_project' and destructiveHint: true",
        "All 4 tools use plain Zod objects for schema (NOT z.object())",
        "All 4 tools are imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Depends on PRD-P1 for CreateProjectRequest, UpdateProjectRequest types. The existing getProject function uses positional args; refactor it to options object for consistency.",
      "claimed_by": "agent-1",
      "claimed_at": "2026-02-19T20:55:18Z"
    },
    {
      "id": "PRD-P4",
      "title": "Branch CRUD + portfolio-wide project and branch queries",
      "description": "Implement full CRUD for a single branch resource, plus two portfolio-wide list endpoints. This story adds 5 new API functions, 5 new service wrappers, and 6 MCP tool files.\n\n**API layer (src/api/portfolio.ts):**\nThe existing `getBranches` already fetches the branch list under a project. Add:\n\n1. `getBranch(params: { portfolioId: string; applicationId: string; projectId: string; branchId: string }): Promise<Branch>` - GET `/api/portfolios/${portfolioId}/applications/${applicationId}/projects/${projectId}/branches/${branchId}`. Use `client.get<Branch>(path, undefined, ACCEPT_BRANCHES)`. ACCEPT_BRANCHES already exists as `application/vnd.polaris.portfolios.branches-1+json`.\n2. `createBranch(params: { portfolioId: string; applicationId: string; projectId: string; body: CreateBranchRequest }): Promise<Branch>` - POST to `/api/portfolios/${portfolioId}/applications/${applicationId}/projects/${projectId}/branches`. Use `client.fetch<Branch>(path, { method: 'POST', body: params.body, accept: ACCEPT_BRANCHES, contentType: ACCEPT_BRANCHES })`.\n3. `updateBranch(params: { portfolioId: string; applicationId: string; projectId: string; branchId: string; body: UpdateBranchRequest }): Promise<Branch>` - PATCH to same path with /${branchId}. Use `client.fetch<Branch>(path, { method: 'PATCH', body: params.body, accept: ACCEPT_BRANCHES, contentType: ACCEPT_BRANCHES })`.\n4. `deleteBranch(params: { portfolioId: string; applicationId: string; projectId: string; branchId: string }): Promise<void>` - DELETE to same path with /${branchId}. Use `client.fetch<void>(path, { method: 'DELETE', accept: ACCEPT_BRANCHES })`.\n5. `getPortfolioBranches(params: { portfolioId: string; filter?: string; sort?: string }): Promise<Branch[]>` - GET `/api/portfolios/${portfolioId}/branches`. Use `client.getAllOffset<Branch>(path, queryParams, ACCEPT_BRANCHES)`. This is the portfolio-wide branch listing (different from the project-scoped getBranches that already exists).\n\nNote: The portfolio-wide project listing `GET /{portfolioId}/projects` already exists in the `getProjects` function when `applicationId` is omitted, so no new API function is needed for that. However, a dedicated tool should be created.\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interfaces and wrapper functions:\n- `GetBranchOptions { portfolioId: string; applicationId: string; projectId: string; branchId: string }`\n- `CreateBranchOptions { portfolioId: string; applicationId: string; projectId: string; name: string }`\n- `UpdateBranchOptions { portfolioId: string; applicationId: string; projectId: string; branchId: string; name?: string; isDefault?: boolean }`\n- `DeleteBranchOptions { portfolioId: string; applicationId: string; projectId: string; branchId: string }`\n- `GetPortfolioBranchesOptions { portfolioId: string; filter?: string; sort?: string }`\n\n**Tool files (src/mcp/tools/):**\n\n1. `get-branch.ts` - Tool name: `get_branch`. Schema: portfolio_id, application_id, project_id, branch_id (all z.string()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n2. `create-branch.ts` - Tool name: `create_branch`. Schema: portfolio_id, application_id, project_id, name (all z.string()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n3. `update-branch.ts` - Tool name: `update_branch`. Schema: portfolio_id, application_id, project_id, branch_id (z.string()), name (z.string().optional()), is_default (z.boolean().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n4. `delete-branch.ts` - Tool name: `delete_branch`. Schema: portfolio_id, application_id, project_id, branch_id (z.string()). Annotations: `{ readOnlyHint: false, destructiveHint: true, openWorldHint: true }`.\n5. `get-portfolio-projects.ts` - Tool name: `get_portfolio_projects`. Schema: portfolio_id (z.string()), filter (z.string().optional()), sort (z.string().optional()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`. Description: 'List all projects across all applications in a portfolio (portfolio-wide view).' Handler calls existing `getProjects({ portfolioId: portfolio_id, filter, sort })` from services.\n6. `get-portfolio-branches.ts` - Tool name: `get_portfolio_branches`. Schema: portfolio_id (z.string()), filter (z.string().optional()), sort (z.string().optional()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`. Description: 'List all branches across all projects in a portfolio (portfolio-wide view).' Handler calls `getPortfolioBranches()` from services.\n\n**Register all 6 tools** in src/mcp/tools/index.ts.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml paths /{portfolioId}/applications/{applicationId}/projects/{projectId}/branches, /{portfolioId}/applications/{applicationId}/projects/{projectId}/branches/{id}, /{portfolioId}/projects, /{portfolioId}/branches.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports getBranch, createBranch, updateBranch, deleteBranch, getPortfolioBranches functions",
        "All branch API functions use the ACCEPT_BRANCHES constant for Accept and Content-Type headers",
        "createBranch uses client.fetch with method POST",
        "updateBranch uses client.fetch with method PATCH",
        "deleteBranch uses client.fetch with method DELETE",
        "getPortfolioBranches uses client.getAllOffset for paginated retrieval",
        "src/services/portfolio.ts exports GetBranchOptions, CreateBranchOptions, UpdateBranchOptions, DeleteBranchOptions, GetPortfolioBranchesOptions interfaces and corresponding functions",
        "src/mcp/tools/get-branch.ts exists with tool name 'get_branch' and readOnlyHint: true",
        "src/mcp/tools/create-branch.ts exists with tool name 'create_branch' and readOnlyHint: false",
        "src/mcp/tools/update-branch.ts exists with tool name 'update_branch' and readOnlyHint: false",
        "src/mcp/tools/delete-branch.ts exists with tool name 'delete_branch' and destructiveHint: true",
        "src/mcp/tools/get-portfolio-projects.ts exists with tool name 'get_portfolio_projects' and readOnlyHint: true",
        "src/mcp/tools/get-portfolio-branches.ts exists with tool name 'get_portfolio_branches' and readOnlyHint: true",
        "All 6 tools use plain Zod objects for schema (NOT z.object())",
        "All 6 tools are imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Depends on PRD-P1 for CreateBranchRequest, UpdateBranchRequest types. The portfolio-wide project list already works via the existing getProjects function when applicationId is omitted, so get-portfolio-projects.ts just needs a dedicated tool wrapping that call.",
      "claimed_by": "agent-1",
      "claimed_at": "2026-02-19T20:58:26Z"
    },
    {
      "id": "PRD-P5",
      "title": "Project sub-resources + profiles",
      "description": "Implement project sub-resource listing, sub-resource count, profile get, and profile update. This adds 4 API functions, 4 service wrappers, and 4 MCP tool files.\n\n**API layer (src/api/portfolio.ts):**\nAdd a new Accept constant: `const ACCEPT_SUB_RESOURCES = 'application/vnd.polaris.portfolios.project-sub-resources-1+json';` and `const ACCEPT_PROFILES = 'application/vnd.polaris.portfolios.profiles-1+json';`.\n\n1. `getProjectSubResources(params: { portfolioId: string; filter?: string; sort?: string; considerInheritedLabels?: boolean }): Promise<ProjectSubResource[]>` - GET `/api/portfolios/${portfolioId}/project-sub-resources`. Use `client.getAllOffset<ProjectSubResource>(path, queryParams, ACCEPT_SUB_RESOURCES)`. Pass _filter, _sort, _considerInheritedLabels as query params.\n2. `getProjectSubResourceCount(params: { portfolioId: string; filter?: string; sort?: string; group?: string }): Promise<ProjectSubResourceCountItem[]>` - GET `/api/portfolios/${portfolioId}/project-sub-resources/_actions/count`. Use `client.getAllOffset<ProjectSubResourceCountItem>(path, queryParams, ACCEPT_SUB_RESOURCES)`. Pass _filter, _sort, _group as query params.\n3. `getProfile(params: { portfolioId: string; applicationId: string; projectId: string; profileId: string }): Promise<Profile>` - GET `/api/portfolios/${portfolioId}/applications/${applicationId}/projects/${projectId}/profiles/${profileId}`. Use `client.get<Profile>(path, undefined, ACCEPT_PROFILES)`.\n4. `updateProfile(params: { portfolioId: string; applicationId: string; projectId: string; profileId: string; body: Record<string, unknown> }): Promise<Profile>` - PUT to same path. Use `client.fetch<Profile>(path, { method: 'PUT', body: params.body, accept: ACCEPT_PROFILES, contentType: ACCEPT_PROFILES })`. The body is a generic Record because the profile schema is polymorphic (forms, saml, selenium, none, import).\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interfaces and wrapper functions:\n- `GetProjectSubResourcesOptions { portfolioId: string; filter?: string; sort?: string; considerInheritedLabels?: boolean }`\n- `GetProjectSubResourceCountOptions { portfolioId: string; filter?: string; sort?: string; group?: string }`\n- `GetProfileOptions { portfolioId: string; applicationId: string; projectId: string; profileId: string }`\n- `UpdateProfileOptions { portfolioId: string; applicationId: string; projectId: string; profileId: string; body: Record<string, unknown> }`\n\n**Tool files (src/mcp/tools/):**\n\n1. `get-project-sub-resources.ts` - Tool name: `get_project_sub_resources`. Schema: portfolio_id (z.string()), filter (z.string().optional().describe('RSQL filter. Filterable: id, name, projectSubResourceType, default, project.id, project.name, application.id, application.name, additionalProperties.source, _labelName')), sort (z.string().optional()), consider_inherited_labels (z.boolean().optional()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n2. `get-project-sub-resource-count.ts` - Tool name: `get_project_sub_resource_count`. Schema: portfolio_id (z.string()), filter (z.string().optional()), sort (z.string().optional()), group (z.string().optional().describe('Group by field name for counting')). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n3. `get-profile.ts` - Tool name: `get_profile`. Schema: portfolio_id, application_id, project_id, profile_id (all z.string()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n4. `update-profile.ts` - Tool name: `update_profile`. Schema: portfolio_id, application_id, project_id, profile_id (z.string()), body (z.string().describe('JSON string of profile update payload - schema is polymorphic, see specs/portfolio.yaml')). Annotations: `{ readOnlyHint: false, openWorldHint: true }`. Handler must JSON.parse the body string before passing to the service.\n\n**Register all 4 tools** in src/mcp/tools/index.ts.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml paths /{portfolioId}/project-sub-resources, /{portfolioId}/project-sub-resources/_actions/count, /{portfolioId}/applications/{applicationId}/projects/{projectId}/profiles/{profileId}.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports getProjectSubResources, getProjectSubResourceCount, getProfile, updateProfile functions",
        "ACCEPT_SUB_RESOURCES constant is defined as 'application/vnd.polaris.portfolios.project-sub-resources-1+json'",
        "ACCEPT_PROFILES constant is defined as 'application/vnd.polaris.portfolios.profiles-1+json'",
        "getProjectSubResources uses client.getAllOffset with ACCEPT_SUB_RESOURCES",
        "getProjectSubResourceCount uses client.getAllOffset with ACCEPT_SUB_RESOURCES",
        "getProfile uses client.get with ACCEPT_PROFILES",
        "updateProfile uses client.fetch with method PUT and ACCEPT_PROFILES for both Accept and Content-Type",
        "src/services/portfolio.ts exports all 4 options interfaces and wrapper functions",
        "src/mcp/tools/get-project-sub-resources.ts exists with tool name 'get_project_sub_resources'",
        "src/mcp/tools/get-project-sub-resource-count.ts exists with tool name 'get_project_sub_resource_count'",
        "src/mcp/tools/get-profile.ts exists with tool name 'get_profile'",
        "src/mcp/tools/update-profile.ts exists with tool name 'update_profile' and readOnlyHint: false",
        "update-profile tool accepts body as a JSON string and parses it before calling the service",
        "All 4 tools are imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Depends on PRD-P1 for ProjectSubResource, ProjectSubResourceCountItem, Profile types. The profile update uses PUT (not PATCH) per the spec. The body is polymorphic (forms/saml/selenium/none/import) so we accept it as a JSON string in the tool.",
      "claimed_by": "agent-4",
      "claimed_at": "2026-02-19T20:59:55Z"
    },
    {
      "id": "PRD-P6",
      "title": "Artifacts + entitlements",
      "description": "Implement artifact creation and retrieval, plus application and portfolio entitlement endpoints. This adds 5 API functions, 5 service wrappers, and 5 MCP tool files.\n\n**API layer (src/api/portfolio.ts):**\nAdd new Accept constants: `const ACCEPT_ARTIFACTS = 'application/vnd.polaris.profile-artifacts-1+json';`, `const ACCEPT_APP_ENTITLEMENTS = 'application/vnd.polaris.portfolios.application-entitlements-1+json';`, `const ACCEPT_ENTITLEMENT_QTY = 'application/vnd.polaris.portfolios.application-entitlements-quantity-1+json';`, `const ACCEPT_PORTFOLIO_ENTITLEMENTS = 'application/vnd.polaris.portfolios.portfolio-entitlements-1+json';`.\n\n1. `createArtifact(params: { portfolioId: string; applicationId: string; body: CreateProfileArtifactRequest }): Promise<ProfileArtifact>` - POST to `/api/portfolios/${portfolioId}/applications/${applicationId}/artifacts`. Use `client.fetch<ProfileArtifact>(path, { method: 'POST', body: params.body, accept: ACCEPT_ARTIFACTS, contentType: ACCEPT_ARTIFACTS })`.\n2. `getArtifact(params: { portfolioId: string; applicationId: string; artifactId: string }): Promise<ProfileArtifact>` - GET `/api/portfolios/${portfolioId}/applications/${applicationId}/artifacts/${artifactId}`. Note: per the spec this endpoint returns `application/octet-stream`, but we model the JSON metadata response as ProfileArtifact. Use `client.get<ProfileArtifact>(path)`.\n3. `getApplicationEntitlements(params: { portfolioId: string; applicationId: string }): Promise<ApplicationEntitlementsResponse>` - GET `/api/portfolios/${portfolioId}/applications/${applicationId}/entitlements`. Use `client.get<ApplicationEntitlementsResponse>(path, undefined, ACCEPT_APP_ENTITLEMENTS)`.\n4. `updateEntitlementQuantity(params: { portfolioId: string; applicationId: string; body: EntitlementQuantityUpdateRequest }): Promise<EntitlementQuantityUpdateResponse>` - PATCH to `/api/portfolios/${portfolioId}/applications/${applicationId}/entitlements/quantity`. Use `client.fetch<EntitlementQuantityUpdateResponse>(path, { method: 'PATCH', body: params.body, accept: ACCEPT_ENTITLEMENT_QTY, contentType: ACCEPT_ENTITLEMENT_QTY })`.\n5. `getPortfolioEntitlements(params: { portfolioId: string }): Promise<PortfolioEntitlement>` - GET `/api/portfolios/${portfolioId}/entitlements`. Use `client.get<PortfolioEntitlement>(path, undefined, ACCEPT_PORTFOLIO_ENTITLEMENTS)`.\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interfaces and wrapper functions:\n- `CreateArtifactOptions { portfolioId: string; applicationId: string; fileName: string; fileHash: string; fileSize: string; artifactType: string }`\n- `GetArtifactOptions { portfolioId: string; applicationId: string; artifactId: string }`\n- `GetApplicationEntitlementsOptions { portfolioId: string; applicationId: string }`\n- `UpdateEntitlementQuantityOptions { portfolioId: string; applicationId: string; entitlementIds: string[]; quantity: number }`\n- `GetPortfolioEntitlementsOptions { portfolioId: string }`\n\n**Tool files (src/mcp/tools/):**\n\n1. `create-artifact.ts` - Tool name: `create_artifact`. Schema: portfolio_id, application_id, file_name, file_hash, file_size, artifact_type (all z.string()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`. Description: 'Create an artifact for an application. Returns a signedUrl for uploading file contents.'\n2. `get-artifact.ts` - Tool name: `get_artifact`. Schema: portfolio_id, application_id, artifact_id (all z.string()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n3. `get-application-entitlements.ts` - Tool name: `get_application_entitlements`. Schema: portfolio_id, application_id (z.string()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n4. `update-entitlement-quantity.ts` - Tool name: `update_entitlement_quantity`. Schema: portfolio_id, application_id (z.string()), entitlement_ids (z.array(z.string()).describe('Array of entitlement UUIDs')), quantity (z.number().describe('Subscription quantity to allocate')). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n5. `get-portfolio-entitlements.ts` - Tool name: `get_portfolio_entitlements`. Schema: portfolio_id (z.string()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n\n**Register all 5 tools** in src/mcp/tools/index.ts.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml paths /{portfolioId}/applications/{applicationId}/artifacts, /{portfolioId}/applications/{applicationId}/artifacts/{artifactId}, /{portfolioId}/applications/{applicationId}/entitlements, /{portfolioId}/applications/{applicationId}/entitlements/quantity, /{portfolioId}/entitlements.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports createArtifact, getArtifact, getApplicationEntitlements, updateEntitlementQuantity, getPortfolioEntitlements functions",
        "ACCEPT_ARTIFACTS, ACCEPT_APP_ENTITLEMENTS, ACCEPT_ENTITLEMENT_QTY, ACCEPT_PORTFOLIO_ENTITLEMENTS constants are defined",
        "createArtifact uses client.fetch with method POST and ACCEPT_ARTIFACTS",
        "updateEntitlementQuantity uses client.fetch with method PATCH and ACCEPT_ENTITLEMENT_QTY",
        "src/services/portfolio.ts exports all 5 options interfaces and wrapper functions",
        "src/mcp/tools/create-artifact.ts exists with tool name 'create_artifact' and readOnlyHint: false",
        "src/mcp/tools/get-artifact.ts exists with tool name 'get_artifact' and readOnlyHint: true",
        "src/mcp/tools/get-application-entitlements.ts exists with tool name 'get_application_entitlements' and readOnlyHint: true",
        "src/mcp/tools/update-entitlement-quantity.ts exists with tool name 'update_entitlement_quantity' and readOnlyHint: false",
        "src/mcp/tools/get-portfolio-entitlements.ts exists with tool name 'get_portfolio_entitlements' and readOnlyHint: true",
        "All 5 tools are imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Depends on PRD-P1 for CreateProfileArtifactRequest, ProfileArtifact, ApplicationEntitlementsResponse, EntitlementQuantityUpdateRequest, EntitlementQuantityUpdateResponse, PortfolioEntitlement types.",
      "claimed_by": "agent-1",
      "claimed_at": "2026-02-19T21:02:50Z"
    },
    {
      "id": "PRD-P7",
      "title": "Labels CRUD + merge",
      "description": "Implement full CRUD for labels plus a merge operation. Labels are organization-level resources under /api/portfolios/labels (no portfolioId in path). This adds 6 API functions, 6 service wrappers, and 6 MCP tool files.\n\n**API layer (src/api/portfolio.ts):**\nAdd a new Accept constant: `const ACCEPT_LABELS = 'application/vnd.polaris.portfolios.labels-1+json';`.\n\n1. `createLabel(params: { body: CreateLabelRequest }): Promise<Label>` - POST to `/api/portfolios/labels`. Use `client.fetch<Label>(path, { method: 'POST', body: params.body, accept: ACCEPT_LABELS, contentType: ACCEPT_LABELS })`.\n2. `getLabels(params: { filter?: string; sort?: string }): Promise<Label[]>` - GET `/api/portfolios/labels`. Use `client.getAllOffset<Label>(path, queryParams, ACCEPT_LABELS)`. Pass _filter, _sort as query params.\n3. `getLabel(params: { labelId: string; includeUsageStats?: boolean }): Promise<Label>` - GET `/api/portfolios/labels/${labelId}`. Use `client.get<Label>(path, queryParams, ACCEPT_LABELS)`. Pass includeUsageStats as query param if provided.\n4. `updateLabel(params: { labelId: string; body: CreateLabelRequest }): Promise<Label>` - PATCH to `/api/portfolios/labels/${labelId}`. Use `client.fetch<Label>(path, { method: 'PATCH', body: params.body, accept: ACCEPT_LABELS, contentType: ACCEPT_LABELS })`.\n5. `deleteLabel(params: { labelId: string }): Promise<void>` - DELETE to `/api/portfolios/labels/${labelId}`. Use `client.fetch<void>(path, { method: 'DELETE', accept: ACCEPT_LABELS })`. Returns 204.\n6. `mergeLabels(params: { body: MergeLabelRequest }): Promise<Label>` - POST to `/api/portfolios/labels/merge`. Use `client.fetch<Label>(path, { method: 'POST', body: params.body, accept: ACCEPT_LABELS, contentType: ACCEPT_LABELS })`.\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interfaces and wrapper functions:\n- `CreateLabelOptions { name: string; description?: string }`\n- `GetLabelsOptions { filter?: string; sort?: string }`\n- `GetLabelOptions { labelId: string; includeUsageStats?: boolean }`\n- `UpdateLabelOptions { labelId: string; name?: string; description?: string }`\n- `DeleteLabelOptions { labelId: string }`\n- `MergeLabelsOptions { labelsToMerge: string[]; targetName: string; targetDescription?: string }`\n\n**Tool files (src/mcp/tools/):**\n\n1. `create-label.ts` - Tool name: `create_label`. Schema: name (z.string()), description (z.string().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n2. `get-labels.ts` - Tool name: `get_labels`. Schema: filter (z.string().optional().describe('RSQL filter. Filterable: id, name')), sort (z.string().optional()). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n3. `get-label.ts` - Tool name: `get_label`. Schema: label_id (z.string()), include_usage_stats (z.boolean().optional().describe('When true, response includes label usage statistics for Application and Project')). Annotations: `{ readOnlyHint: true, openWorldHint: true }`.\n4. `update-label.ts` - Tool name: `update_label`. Schema: label_id (z.string()), name (z.string().optional()), description (z.string().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n5. `delete-label.ts` - Tool name: `delete_label`. Schema: label_id (z.string()). Annotations: `{ readOnlyHint: false, destructiveHint: true, openWorldHint: true }`.\n6. `merge-labels.ts` - Tool name: `merge_labels`. Schema: labels_to_merge (z.array(z.string()).describe('Array of label UUIDs to merge')), target_name (z.string().describe('Name for the merged label')), target_description (z.string().optional()). Annotations: `{ readOnlyHint: false, openWorldHint: true }`.\n\n**Register all 6 tools** in src/mcp/tools/index.ts.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml paths /labels, /labels/{id}, /labels/merge.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports createLabel, getLabels, getLabel, updateLabel, deleteLabel, mergeLabels functions",
        "ACCEPT_LABELS constant is defined as 'application/vnd.polaris.portfolios.labels-1+json'",
        "createLabel uses client.fetch with method POST and ACCEPT_LABELS",
        "getLabels uses client.getAllOffset for paginated retrieval with ACCEPT_LABELS",
        "getLabel uses client.get with ACCEPT_LABELS and passes includeUsageStats as query param",
        "updateLabel uses client.fetch with method PATCH and ACCEPT_LABELS",
        "deleteLabel uses client.fetch with method DELETE, returns void",
        "mergeLabels uses client.fetch with method POST to /api/portfolios/labels/merge",
        "src/services/portfolio.ts exports all 6 options interfaces and wrapper functions",
        "src/mcp/tools/create-label.ts exists with tool name 'create_label' and readOnlyHint: false",
        "src/mcp/tools/get-labels.ts exists with tool name 'get_labels' and readOnlyHint: true",
        "src/mcp/tools/get-label.ts exists with tool name 'get_label' and readOnlyHint: true",
        "src/mcp/tools/update-label.ts exists with tool name 'update_label' and readOnlyHint: false",
        "src/mcp/tools/delete-label.ts exists with tool name 'delete_label' and destructiveHint: true",
        "src/mcp/tools/merge-labels.ts exists with tool name 'merge_labels' and readOnlyHint: false",
        "All 6 tools are imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Depends on PRD-P1 for Label, CreateLabelRequest, MergeLabelRequest types. Label paths are /api/portfolios/labels (org-level, no portfolioId in path). The merge endpoint body uses { labelsToMerge: string[], targetLabel: { name, description? } } per the MergeLabelPayload schema in specs/portfolio.yaml.",
      "claimed_by": "agent-4",
      "claimed_at": "2026-02-19T21:03:40Z"
    },
    {
      "id": "PRD-P8",
      "title": "Organization settings + risk scoring settings",
      "description": "Implement organization settings get/update and risk scoring settings get/update. These are organization-level resources under /api/portfolios/settings and /api/portfolios/risk-scoring. This adds 4 API functions, 4 service wrappers, and 4 MCP tool files.\n\n**API layer (src/api/portfolio.ts):**\nAdd new Accept constants: `const ACCEPT_SETTINGS = 'application/vnd.polaris.portfolios.settings-1+json';` and `const ACCEPT_RISK_SCORING = 'application/vnd.polaris.portfolios.risk-scoring-settings-1+json';`.\n\n1. `getOrganizationSettings(): Promise<OrganizationSettings>` - GET `/api/portfolios/settings`. Use `client.get<OrganizationSettings>(path, undefined, ACCEPT_SETTINGS)`.\n2. `updateOrganizationSettings(params: { body: Partial<OrganizationSettings> }): Promise<OrganizationSettings>` - PATCH to `/api/portfolios/settings`. Use `client.fetch<OrganizationSettings>(path, { method: 'PATCH', body: params.body, accept: ACCEPT_SETTINGS, contentType: ACCEPT_SETTINGS })`.\n3. `getRiskScoringSettings(): Promise<RiskScoringSettings>` - GET `/api/portfolios/risk-scoring`. Use `client.get<RiskScoringSettings>(path, undefined, ACCEPT_RISK_SCORING)`.\n4. `updateRiskScoringSettings(params: { body: RiskScoringSettings }): Promise<RiskScoringSettings>` - PUT to `/api/portfolios/risk-scoring`. Use `client.fetch<RiskScoringSettings>(path, { method: 'PUT', body: params.body, accept: ACCEPT_RISK_SCORING, contentType: ACCEPT_RISK_SCORING })`.\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interfaces and wrapper functions:\n- `UpdateOrganizationSettingsOptions { allowLabelCreationForApplicationRoleUser?: boolean }`\n- `UpdateRiskScoringSettingsOptions { isEnabled: boolean; riskFactors: RiskFactor[] }`\n\nThe get functions take no options.\n\n**Tool files (src/mcp/tools/):**\n\n1. `get-organization-settings.ts` - Tool name: `get_organization_settings`. Schema: `{ _placeholder: z.string().optional().describe('No parameters required') }`. Annotations: `{ readOnlyHint: true, openWorldHint: true }`. Description: 'Get the organization settings including label creation permissions.'\n2. `update-organization-settings.ts` - Tool name: `update_organization_settings`. Schema: allow_label_creation (z.boolean().describe('Whether application role users can create labels')). Annotations: `{ readOnlyHint: false, openWorldHint: true }`. Description: 'Update organization settings.'\n3. `get-risk-scoring-settings.ts` - Tool name: `get_risk_scoring_settings`. Schema: `{ _placeholder: z.string().optional().describe('No parameters required') }`. Annotations: `{ readOnlyHint: true, openWorldHint: true }`. Description: 'Get the organization risk scoring settings including risk factors and categories.'\n4. `update-risk-scoring-settings.ts` - Tool name: `update_risk_scoring_settings`. Schema: is_enabled (z.boolean().describe('Enable or disable risk scoring for the organization')), risk_factors (z.string().describe('JSON string of risk factors array. Each factor: { name, weight (1-100), description, defaultCategory (uuid or 0-based index), categories: [{ name, impact (0-10) }] }. Sum of weights must equal 100.')). Annotations: `{ readOnlyHint: false, openWorldHint: true }`. Handler must JSON.parse the risk_factors string.\n\n**Register all 4 tools** in src/mcp/tools/index.ts.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml paths /settings and /risk-scoring.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports getOrganizationSettings, updateOrganizationSettings, getRiskScoringSettings, updateRiskScoringSettings functions",
        "ACCEPT_SETTINGS constant is defined as 'application/vnd.polaris.portfolios.settings-1+json'",
        "ACCEPT_RISK_SCORING constant is defined as 'application/vnd.polaris.portfolios.risk-scoring-settings-1+json'",
        "getOrganizationSettings uses client.get with ACCEPT_SETTINGS",
        "updateOrganizationSettings uses client.fetch with method PATCH and ACCEPT_SETTINGS",
        "getRiskScoringSettings uses client.get with ACCEPT_RISK_SCORING",
        "updateRiskScoringSettings uses client.fetch with method PUT and ACCEPT_RISK_SCORING",
        "src/services/portfolio.ts exports UpdateOrganizationSettingsOptions, UpdateRiskScoringSettingsOptions interfaces and all 4 wrapper functions",
        "src/mcp/tools/get-organization-settings.ts exists with tool name 'get_organization_settings' and readOnlyHint: true",
        "src/mcp/tools/update-organization-settings.ts exists with tool name 'update_organization_settings' and readOnlyHint: false",
        "src/mcp/tools/get-risk-scoring-settings.ts exists with tool name 'get_risk_scoring_settings' and readOnlyHint: true",
        "src/mcp/tools/update-risk-scoring-settings.ts exists with tool name 'update_risk_scoring_settings' and readOnlyHint: false",
        "update-risk-scoring-settings tool accepts risk_factors as a JSON string and parses it before calling the service",
        "All 4 tools are imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 4,
      "passes": false,
      "notes": "Depends on PRD-P1 for OrganizationSettings, RiskScoringSettings, RiskFactor, RiskCategory types. Settings paths are /api/portfolios/settings and /api/portfolios/risk-scoring (org-level, no portfolioId). Risk scoring update uses PUT (not PATCH) per the spec. The risk factors array is complex so we accept it as a JSON string in the tool.",
      "claimed_by": "agent-4",
      "claimed_at": "2026-02-19T21:07:20Z"
    },
    {
      "id": "PRD-P9",
      "title": "Dashboard",
      "description": "Implement the portfolio dashboard endpoint. This adds 1 API function, 1 service wrapper, and 1 MCP tool file.\n\n**API layer (src/api/portfolio.ts):**\nAdd a new Accept constant: `const ACCEPT_DASHBOARD = 'application/vnd.polaris.portfolios.dashboard-1+json';`. Note: the spec shows the old media type `application/vnd.pm.portfolio-dashboard-1+json` but we should use the new polaris-namespaced one. If the new media type does not work, fall back to the old one.\n\n1. `getDashboard(params: { portfolioId: string; filter?: string; sort?: string }): Promise<DashboardItem[]>` - GET `/api/portfolios/portfolios/${portfolioId}/dashboard`. IMPORTANT: Note the path has a double `portfolios/portfolios` because the base path is `/api/portfolios` and the spec path is `/portfolios/{portfolioId}/dashboard`. Use `client.getAllOffset<DashboardItem>(path, queryParams, ACCEPT_DASHBOARD)`. Pass _filter, _sort as query params.\n\n**Service layer (src/services/portfolio.ts):**\nAdd options interface and wrapper function:\n- `GetDashboardOptions { portfolioId: string; filter?: string; sort?: string }`\n\n**Tool file (src/mcp/tools/):**\n\n1. `get-dashboard.ts` - Tool name: `get_dashboard`. Schema: portfolio_id (z.string().describe('Portfolio ID (get from get_portfolios)')), filter (z.string().optional().describe('RSQL filter. Filterable: portfolioItemName, labelId. Example: portfolioItemName==\\'demo\\'')), sort (z.string().optional().describe('Sort expression. Format: field|direction. Sortable: portfolioItemName. Example: portfolioItemName|asc')). Annotations: `{ readOnlyHint: true, openWorldHint: true }`. Description: 'Get the portfolio dashboard with application-level issue metrics, risk scores, and scan status. Returns dashboard items for all applications matching the filter.'\n\n**Register the tool** in src/mcp/tools/index.ts.\n\nRun `deno task check`, `deno task lint`, and `deno fmt --check` to verify. Reference: specs/portfolio.yaml path /portfolios/{portfolioId}/dashboard.",
      "acceptanceCriteria": [
        "src/api/portfolio.ts exports getDashboard function",
        "ACCEPT_DASHBOARD constant is defined as 'application/vnd.polaris.portfolios.dashboard-1+json'",
        "getDashboard uses client.getAllOffset for paginated retrieval with ACCEPT_DASHBOARD",
        "getDashboard path is /api/portfolios/portfolios/${portfolioId}/dashboard (double portfolios because base path is /api/portfolios and spec path starts with /portfolios/)",
        "getDashboard passes _filter and _sort as query params",
        "src/services/portfolio.ts exports GetDashboardOptions interface and getDashboard wrapper function",
        "src/mcp/tools/get-dashboard.ts exists with tool name 'get_dashboard' and readOnlyHint: true",
        "get-dashboard tool schema has portfolio_id, filter (optional), sort (optional) as plain Zod objects",
        "The tool is imported and added to the tools array in src/mcp/tools/index.ts",
        "`deno task check` passes with zero errors",
        "`deno task lint` passes with zero errors",
        "`deno fmt --check` passes with zero errors"
      ],
      "priority": 4,
      "passes": false,
      "notes": "Depends on PRD-P1 for DashboardItem type. The spec shows the legacy media type application/vnd.pm.portfolio-dashboard-1+json but we should try the new polaris-namespaced convention first: application/vnd.polaris.portfolios.dashboard-1+json. The API path requires careful construction: the spec shows /portfolios/{portfolioId}/dashboard relative to the server base https://polaris.blackduck.com/api/portfolios, so the full path from code is /api/portfolios/portfolios/{portfolioId}/dashboard."
    }
  ]
}
